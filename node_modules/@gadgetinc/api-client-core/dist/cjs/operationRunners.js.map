{"version":3,"file":"operationRunners.js","sourceRoot":"","sources":["../../src/operationRunners.ts"],"names":[],"mappings":"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","sourcesContent":["import { BackgroundActionHandle } from \"./BackgroundActionHandle.js\";\nimport type { FieldSelection } from \"./FieldSelection.js\";\nimport type { GadgetConnection } from \"./GadgetConnection.js\";\nimport { AnyActionFunction } from \"./GadgetFunctions.js\";\nimport type { GadgetRecord, RecordShape } from \"./GadgetRecord.js\";\nimport { GadgetRecordList } from \"./GadgetRecordList.js\";\nimport type { AnyModelManager } from \"./ModelManager.js\";\nimport {\n  actionOperation,\n  enqueueActionOperation,\n  findManyOperation,\n  findOneByFieldOperation,\n  findOneOperation,\n  globalActionOperation,\n} from \"./operationBuilders.js\";\nimport {\n  GadgetErrorGroup,\n  assertMutationSuccess,\n  assertNullableOperationSuccess,\n  assertOperationSuccess,\n  disambiguateActionVariables,\n  disambiguateBulkActionVariables,\n  gadgetErrorFor,\n  get,\n  getNonUniqueDataError,\n  hydrateConnection,\n  hydrateRecord,\n  hydrateRecordArray,\n  setVariableOptionValues,\n} from \"./support.js\";\nimport type { BaseFindOptions, EnqueueBackgroundActionOptions, FindManyOptions, VariablesOptions } from \"./types.js\";\n\nexport const findOneRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  id: string | undefined,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: BaseFindOptions | null,\n  throwOnEmptyData = true\n) => {\n  const plan = findOneOperation(operation, id, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n  const assertSuccess = throwOnEmptyData ? assertOperationSuccess : assertNullableOperationSuccess;\n  const record = assertSuccess(response, [operation]);\n  return hydrateRecord<Shape>(response, record);\n};\n\nexport const findOneByFieldRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  fieldName: string,\n  fieldValue: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: BaseFindOptions | null\n) => {\n  const plan = findOneByFieldOperation(operation, fieldName, fieldValue, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n  const connectionObject = assertOperationSuccess(response, [operation]);\n  const records = hydrateConnection<Shape>(response, connectionObject);\n\n  if (records.length > 1) {\n    throw getNonUniqueDataError(modelApiIdentifier, fieldName, fieldValue);\n  }\n\n  return records[0];\n};\n\nexport const findManyRunner = async <Shape extends RecordShape = any>(\n  modelManager: AnyModelManager,\n  operation: string,\n  defaultSelection: FieldSelection,\n  modelApiIdentifier: string,\n  options?: FindManyOptions,\n  throwOnEmptyData?: boolean\n) => {\n  const plan = findManyOperation(operation, defaultSelection, modelApiIdentifier, options);\n  const response = await modelManager.connection.currentClient.query(plan.query, plan.variables).toPromise();\n\n  let connectionObject;\n  if (throwOnEmptyData === false) {\n    // If this is a nullable operation, don't throw errors on empty\n    connectionObject = assertNullableOperationSuccess(response, [operation]);\n  } else {\n    // Otherwise, passthrough the `throwOnEmptyData` flag, to account for\n    // `findMany` (allows empty arrays) vs `findFirst` (no empty result) usage.\n    connectionObject = assertOperationSuccess(response, [operation], throwOnEmptyData);\n  }\n\n  const records = hydrateConnection<Shape>(response, connectionObject);\n  return GadgetRecordList.boot<Shape>(modelManager, records, { options, pageInfo: connectionObject.pageInfo });\n};\n\nexport interface ActionRunner {\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: true\n  ): Promise<any>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: false\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: false,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n\n  (\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: true\n  ): Promise<any[]>;\n\n  <Shape extends RecordShape = any>(\n    modelManager: { connection: GadgetConnection },\n    operation: string,\n    defaultSelection: FieldSelection | null,\n    modelApiIdentifier: string,\n    modelSelectionField: string,\n    isBulkAction: true,\n    variables: VariablesOptions,\n    options?: BaseFindOptions | null,\n    namespace?: string | null,\n    hasReturnType?: false\n  ): Promise<Shape extends void ? void : GadgetRecord<Shape>[]>;\n}\n\nexport const actionRunner: ActionRunner = async <Shape extends RecordShape = any>(\n  modelManager: { connection: GadgetConnection },\n  operation: string,\n  defaultSelection: FieldSelection | null,\n  modelApiIdentifier: string,\n  modelSelectionField: string,\n  isBulkAction: boolean,\n  variables: VariablesOptions,\n  options?: BaseFindOptions | null,\n  namespace?: string | null,\n  hasReturnType?: boolean | null\n) => {\n  const plan = actionOperation(\n    operation,\n    defaultSelection,\n    modelApiIdentifier,\n    modelSelectionField,\n    variables,\n    options,\n    namespace,\n    isBulkAction,\n    hasReturnType\n  );\n  const response = await modelManager.connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n\n  // pass bulk responses through without any assertions since we can have a success: false response but still want\n  // to process it in a similar fashion since some of the records could have been processed\n  const dataPath = namespace ? [namespace, operation] : [operation];\n\n  if (!isBulkAction) {\n    const mutationTriple = assertMutationSuccess(response, dataPath);\n    // Delete actions have a null selection. We do an early return for this because `hydrateRecordArray` will fail\n    // if there's nothing at `mutationResult[modelSelectionField]`, but the caller isn't expecting a return (void).\n    if (defaultSelection == null) return;\n    if (!hasReturnType) {\n      return hydrateRecord<Shape>(response, mutationTriple[modelSelectionField]);\n    } else {\n      return mutationTriple.result;\n    }\n  } else {\n    const mutationTriple = get(response.data, dataPath);\n    const results =\n      mutationTriple[modelSelectionField] && defaultSelection\n        ? hydrateRecordArray<Shape>(response, mutationTriple[modelSelectionField])\n        : undefined;\n    if (mutationTriple.errors) {\n      const errors = mutationTriple.errors.map((error: any) => gadgetErrorFor(error));\n      throw new GadgetErrorGroup(errors, results);\n    }\n\n    return results;\n  }\n};\n\nexport const globalActionRunner = async (\n  connection: GadgetConnection,\n  operation: string,\n  variables: VariablesOptions,\n  namespace?: string | null\n) => {\n  const plan = globalActionOperation(operation, variables, namespace);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables).toPromise();\n  const dataPath = namespace ? [namespace, operation] : [operation];\n  return assertMutationSuccess(response, dataPath).result;\n};\n\nexport const enqueueActionRunner = async <Action extends AnyActionFunction>(\n  connection: GadgetConnection,\n  action: Action,\n  variables: Action[\"variablesType\"],\n  options: EnqueueBackgroundActionOptions<Action> = {}\n) => {\n  const normalizedVariableValues =\n    \"isBulk\" in action && action.isBulk\n      ? disambiguateBulkActionVariables(action, variables)\n      : disambiguateActionVariables(action, variables);\n  const variableOptions = setVariableOptionValues(action.variables, normalizedVariableValues);\n\n  const plan = enqueueActionOperation(action.operationName, variableOptions, action.namespace, options);\n  const response = await connection.currentClient.mutation(plan.query, plan.variables, options).toPromise();\n  const dataPath = [\"background\", action.operationName];\n  if (action.namespace) {\n    dataPath.unshift(action.namespace);\n  }\n\n  try {\n    const result = assertMutationSuccess(response, dataPath);\n    return new BackgroundActionHandle(connection, result.backgroundAction.id, options);\n  } catch (error: any) {\n    if (\"code\" in error && error.code == \"GGT_DUPLICATE_BACKGROUND_ACTION_ID\" && options?.id && options.onDuplicateID == \"ignore\") {\n      return new BackgroundActionHandle(connection, options.id, options);\n    }\n    throw error;\n  }\n};\n"]}