'use strict';

var React = require('react');
var debounce = require('../../../utilities/debounce.js');

const DEBOUNCE_PERIOD = 250;
const SELECT_ALL_ACTIONS_HEIGHT = 41;
const PAGINATION_WIDTH_OFFSET = 64;
const SCROLL_BAR_CONTAINER_HEIGHT = 13;
const SCROLL_BAR_HEIGHT = 8;
const INDEX_TABLE_INITIAL_OFFSET = 32;
const RESOURCE_LIST_INITIAL_OFFSET = 48;
function useIsSelectAllActionsSticky({
  selectMode,
  hasPagination,
  tableType
}) {
  const hasIOSupport = typeof window !== 'undefined' && Boolean(window.IntersectionObserver);
  const [isSelectAllActionsSticky, setIsSticky] = React.useState(false);
  const [isScrolledPastTop, setIsScrolledPastTop] = React.useState(false);
  const [selectAllActionsAbsoluteOffset, setSelectAllActionsAbsoluteOffset] = React.useState(0);
  const [selectAllActionsMaxWidth, setSelectAllActionsMaxWidth] = React.useState(0);
  const [selectAllActionsOffsetLeft, setSelectAllActionsOffsetLeft] = React.useState(0);
  const [selectAllActionsOffsetBottom, setSelectAllActionsOffsetBottom] = React.useState(0);
  const selectAllActionsIntersectionRef = React.useRef(null);
  const tableMeasurerRef = React.useRef(null);
  const widthOffset = hasPagination ? PAGINATION_WIDTH_OFFSET : 0;
  const initialPostOffset = tableType === 'index-table' ? INDEX_TABLE_INITIAL_OFFSET + SCROLL_BAR_CONTAINER_HEIGHT : RESOURCE_LIST_INITIAL_OFFSET;
  const postScrollOffset = initialPostOffset + SELECT_ALL_ACTIONS_HEIGHT;
  const handleIntersect = entries => {
    entries.forEach(entry => {
      setIsSticky(!entry.isIntersecting);
    });
  };
  const handleTableIntersect = entries => {
    entries.forEach(entry => {
      const isScrolledPastTop = entry.boundingClientRect.top > 0 && !entry.isIntersecting;
      const rootBoundsHeight = entry.rootBounds?.height || 0;
      const hasTableOffscreen = entry.boundingClientRect.top + entry.boundingClientRect.height > rootBoundsHeight;
      if (hasTableOffscreen && entry.rootBounds) {
        setIsSticky(entry.isIntersecting);
      }
      setIsScrolledPastTop(isScrolledPastTop);
    });
  };
  const options = {
    root: null,
    rootMargin: '0px',
    threshold: 0
  };
  const observerRef = React.useRef(hasIOSupport ? new IntersectionObserver(handleIntersect, options) : null);
  const tableOptions = {
    root: null,
    rootMargin: `0px 0px -${postScrollOffset}px 0px`,
    threshold: 0
  };
  const tableObserverRef = React.useRef(hasIOSupport ? new IntersectionObserver(handleTableIntersect, tableOptions) : null);
  const getClosestScrollContainer = node => {
    let container = node;
    while (container && container !== document.body) {
      const style = window.getComputedStyle(container);
      const isScrollContainer = style.overflow === 'auto' || style.overflowX === 'auto' || style.overflowY === 'auto' || style.overflow === 'scroll' || style.overflowX === 'scroll' || style.overflowY === 'scroll';
      if (isScrollContainer) return container;
      container = container.parentElement;
    }
    return null;
  };
  const computeTableDimensions = React.useCallback(() => {
    const node = tableMeasurerRef.current;
    if (!node) {
      return {
        maxWidth: 0,
        offsetHeight: 0,
        offsetLeft: 0,
        offsetBottom: 0
      };
    }
    const scrollContainer = getClosestScrollContainer(node)?.getBoundingClientRect();
    const box = node.getBoundingClientRect();
    const paddingHeight = selectMode ? SELECT_ALL_ACTIONS_HEIGHT : 0;
    const offsetHeight = box.height - paddingHeight;
    const maxWidth = box.width - widthOffset;
    const offsetLeft = box.left;
    const offsetBottomScrollable = scrollContainer ? Math.round(scrollContainer.y + SCROLL_BAR_HEIGHT) : 0;
    setSelectAllActionsAbsoluteOffset(offsetHeight);
    setSelectAllActionsMaxWidth(maxWidth);
    setSelectAllActionsOffsetLeft(offsetLeft);
    setSelectAllActionsOffsetBottom(offsetBottomScrollable);
  }, [selectMode, widthOffset]);
  const computeDimensionsPastScroll = React.useCallback(() => {
    setSelectAllActionsAbsoluteOffset(initialPostOffset);
  }, [initialPostOffset]);
  React.useEffect(() => {
    if (isScrolledPastTop) {
      computeDimensionsPastScroll();
    } else {
      computeTableDimensions();
    }
    const debouncedComputeTableHeight = debounce.debounce(computeTableDimensions, DEBOUNCE_PERIOD, {
      trailing: true
    });
    window.addEventListener('resize', debouncedComputeTableHeight);
    return () => window.removeEventListener('resize', debouncedComputeTableHeight);
  }, [isScrolledPastTop, computeDimensionsPastScroll, computeTableDimensions]);
  React.useEffect(() => {
    const observer = observerRef.current;
    const tableObserver = tableObserverRef.current;
    if (!observer || !tableObserver) {
      return;
    }
    const node = selectAllActionsIntersectionRef.current;
    const tableNode = tableMeasurerRef.current;
    if (node) {
      observer.observe(node);
    }
    if (tableNode) {
      tableObserver.observe(tableNode);
    }
    return () => {
      observer?.disconnect();
      tableObserver?.disconnect();
    };
  }, [selectAllActionsIntersectionRef]);
  return {
    selectAllActionsIntersectionRef,
    tableMeasurerRef,
    isSelectAllActionsSticky,
    selectAllActionsAbsoluteOffset,
    selectAllActionsMaxWidth,
    selectAllActionsOffsetLeft,
    selectAllActionsOffsetBottom,
    computeTableDimensions,
    isScrolledPastTop,
    selectAllActionsPastTopOffset: initialPostOffset,
    scrollbarPastTopOffset: initialPostOffset - SCROLL_BAR_CONTAINER_HEIGHT
  };
}

exports.useIsSelectAllActionsSticky = useIsSelectAllActionsSticky;
